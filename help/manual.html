<!DOCTYPE html>
<html>
    <head>
        <meta name="description" content="Nape is an open source physics library for Haxe and ActionScript3."/>
        <meta name="keywords" content="Nape,Physics,Haxe,AS3,Flash,Constraint,Rigid,Body,Shape,"/>
        <meta name="author" content="Luca Deltodesco"/>
        <meta charset="UTF-8"/>

        <title>Nape Physics</title>

        <link rel="shortcut icon" href="../assets/ico/favicon.ico"/>
        <link rel="stylesheet" href="../assets/css/puritan.css"/>
        <link rel="stylesheet" href="../assets/css/basestyle.css"/>
        <link rel="stylesheet" href="../assets/prettify/prettify.css"/>
    </head>

    <body>
    <div class="container">
        <div class="title-area">
            <div id="title"></div>
            <script type="text/javascript"> var page="../Help.html~Manual.html"; </script>
            <script type="text/javascript"> var root="../"; </script>
            <div id="menu"></div>
        </div>

        <div class="section-content">
            <div id="submenu"></div>
            <div style="height: 40px"></div>
            <div class="chapter"><strong><span class="title">Introduction</span></strong>
                <div class="contents" id="skip-Introduction"></div>
                <strong><span class="section">About</span></strong>
                <p>
                    <b>Nape</b> is a 2D rigid body physics engine designed for games, written in <b>Haxe</b>, and
                    supporting all Haxe targets. <b>Nape</b> is compiled into <b>.swc</b> libraries for AS3 users.
                    <b>Nape</b> is written for ease of development, with a powerful and succinct API that
                    <i>(outside of a release build)</i> checks it is being used correctly, and reports <b>errors</b> if it is not.
                </p>
                <p>
                    <b>Nape</b> is higher performing than <b>Box2D</b> solutions in AS3/Haxe, and its memory usage is
                    stable and far less than Box2D. <b>Nape</b> supports the majority of Box2D features, as well as many
                    features not included in Box2D such as the <b>geometric utilities</b>, the <b>high-level callbacks</b>
                    system, and more sophisticated <b>buoyancy</b>.
                </p>
                <p>
                    We expect the performance of <b>Nape</b> to be somewhere between 3 and 6 times faster than <b>Box2D</b>
                    on average, whilst using about half the amount of memory (And importantly, having constant memory size).
                    You may also expect the equivalent solution to a problem in <b>Nape</b> to be 2-3 times smaller than in <b>Box2D</b>.
                </p>
                <strong><span class="section">Prerequisites</span></strong>
                <p>
                    I will assume that you are familiar with the physics concepts: <b>mass</b>, <b>moment of inertia</b>,
                    <b>force</b>, <b>torque</b>, <b>density</b>, <b>impulses</b>. If you are not familiar with the term
                    <b>moment of inertia</b>, this is the angular equivalent to <b>mass</b>, similarly <b>torque</b> is
                    the angular equivalent to <b>force</b>. If you are not otherwise familiar with these terms, I suggest
                    you consult Wikipedia.
                </p>
                <strong><span class="section">Units</span></strong>
                <p>
                    <b>Nape</b> uses units of <b>pixels</b> for distances, <i>not</i> metres such as in <b>Box2D</b>. You
                    should keep this in mind as - like with Box2D - physics tuning assumes a rough range of expected sizes
                    in objects; objects should be in most cases, somewhere between 2px at the absolute smallest up to 200px.
                </p>
                <p>
                    <b>Nape</b> uses <b>SI</b> units in all other cases:
                    <ul>
                    <li>
                        <b>seconds</b> as units of time.
                    </li>
                    <li>
                        <b>kilograms</b> as units of mass.
                    </li>
                    <li>
                        <b>clockwise radians</b> as units of angle <i>(Assuming the y-axis is pointing down)</i>.
                    </li>
                    </ul>
                    Other measurements will take expected forms, eg. <b>velocity</b> has units of <b>pixels/second</b>;
                    the single exception is <b>density</b>, which takes units of <b>grams/pixel/pixel</b> so as to keep values sensible
                    <i>(A box measuring 100x100 pixels, with density 1 will in this format have a mass of 10 kilograms)</i>.
                </p>
                <strong><span class="section">API design</span></strong>
                <p>
                    <b>Nape</b> has an API that is in some regards, perhaps unusual compared to the majority of Haxe and AS3
                    APIs. These aspects should be intuitive <i>(if surprisingly so)</i>. For <b>Haxe</b> users, <b>Nape</b> has been written
                    with the <b>flash</b> target as its main focus, and many API choices reflect this by using only a
                    subset of <b>Haxe</b> that has direct equivalents in <b>AS3</b>.
                </p>
                <ul>
                    <li>
                        In <b>AS3</b> you may be more familiar with enumerations <i>(eg. Event::type)</i> as being
                        <b>Strings</b>; in <b>Nape</b> enumerations are strictly-typed as a set of read-only, static
                        fields of the corresponding enum class. <i>(Haxe users, these are not the same as Haxe enums).</i>
                        <pre class="prettyprint standard boxedcode largecodestyle">
var dynamicType:BodyType = BodyType.DYNAMIC;</pre>
                        There are of course, reasons why this is very good; it is <b>impossible</b> to assign an enumeration
                        value that is invalid, and when accessing a property of an object, you <b>know</b> that it is an
                        enumeration, and what values it can take.
                    </li>
                    <br/>
                    <li>
                        In the <b>Flash</b> API, you can often find instances where you have to do things like:
                        <pre class="prettyprint standard boxedcode largecodestyle">
sprite.filters.push(blurFilter);
sprite.filters = sprite.filters; // &lt;--

sprite.transform.a = 2;
sprite.transform = sprite.transform; // &lt;--</pre>
                        In <b>Nape</b>, you do not need to do things like this, the effects of modifying an objects properties
                        is automatically taken into account as part of a <b>lazy</b> system that avoids repeated calculations.
                        <pre class="prettyprint standard boxedcode largecodestyle">
var bodyPosition:Vec2 = body.position;
bodyPosition.x = 10;
// no need to 'refresh' the body, informing it that the position was changed.</pre>
                    </li>
                    <li>
                        In <b>most</b> physics libraries, it is necessary to constantly <i>wake up</i> or <i>activate</i> an object
                        that may have gone to sleep. In <b>Nape</b> these actions are - similar to above - <b>automatic</b>.
                    </li>
                    <br/>
                    <li>
                        In <b>most</b> APIs, you can never be quite sure that you are using the API correctly. It is common to
                        find issues where someone has misused the API but their code has otherwise worked in <b>most</b> cases.
                        Such bugs can be hard to find.
                        <br/>
                        In <b>Nape</b>, when working with the <b>development</b> build, each API usage is checked to ensure that
                        it is <b>valid</b>, and you can be sure that you are not misusing the API - introducing bugs.
                    </li>
                </ul>
                <strong><span class="section">Bug Reports</span></strong>
                <p>
                    If you think you have found a <b>bug</b> in Nape, the very first question I will ask you is: "Are you
                    using the <b>development build</b>?". If, when running your project with the <b>development build</b>, you
                    receive errors then I will <i>not</i> accept your report as it means you are misusing the API and that is
                    the more likely reason why something bad is happening.
                </p>
                <p>
                    If that is not the case, then the procedure for reporting bugs should be to run your project using the
                    <b>debug build</b> (To see if any internal assertions are thrown) and issue a report on
                    <a class="doclink" href="http://github.com/deltaluca/nape">github</a>.
                </p>
                <p>
                    As part
                    of your bug report you should include a <b>minimal test case</b>. The smaller your test case is, the
                    easier it is to track a bug; preferably your test case should <i>not</i> have a <b>main loop</b>, and should
                    certainly not have any <b>user interaction</b>, or be dependent on <b>random numbers</b>.
                </p>
                <strong><span class="section">Packages</span></strong>
                <p>
                    The <b>Nape</b> core is split into the following packages:
                    <table class="dl">
                        <tr><td class="dt"><b>nape:</b></td><td class="tdsp"></td><td>Top-level package</td></tr>
                        <tr><td class="dt"><b>nape.callbacks:</b></td><td class="tdsp"></td><td>Objects related to the callback system, such as
                            <b>CbType</b>, and <b>InteractionListener</b> objects.</td></tr>
                        <tr><td class="dt"><b>nape.constraint:</b></td><td class="tdsp"></td><td>Physics constraints such as the <b>WeldJoint</b> and <b>LineJoint</b></td></tr>
                        <tr><td class="dt"><b>nape.dynamics:</b></td><td class="tdsp"></td><td>Objects related to dynamical interactions such as the <b>Arbiter</b> and <b>Contact</b> types.</td></tr>
                        <tr><td class="dt"><b>nape.geom:</b></td><td class="tdsp"></td><td>Geometric objects such as <b>Vec2</b> and <b>Mat23</b>, as well as geometric utilities
                            available through the <b>Geom</b> and <b>GeomPoly</b> objects among others.</td></tr>
                        <tr><td class="dt"><b>nape.phys:</b></td><td class="tdsp"></td><td>Physics objects such as <b>Body</b>, <b>Compound</b> <i>(Groups bodies
                            and constraints together)</i> and <b>Material</b> <i>(Defines physical properties of <b>Shapes</b>)</i>.</td></tr>
                        <tr><td class="dt"><b>nape.shape:</b></td><td class="tdsp"></td><td>Physics shapes: <b>Circle</b>, <b>Polygon</b> and related objects.</td></tr>
                        <tr><td class="dt"><b>nape.space:</b></td><td class="tdsp"></td><td>Contains the <b>Space</b> object responsible for controlling simulations and related objects.</td></tr>
                        <tr><td class="dt"><b>nape.util:</b></td><td class="tdsp"></td><td>Contains such things as <b>Debug</b> drawing utilities and version information.</td></tr>
                    </table>
                    <dl>
                    </dl>
                </p>
            </div>





            <hr class="hrchapter"/>
            <div class="chapter"><strong><span class="title">Hello Nape</span></strong>
                <div class="contents" id="skip-Hello Nape"></div>
                <p>
                    In this chapter, we will look at creating a basic simulation with <b>Nape</b>.
                </p>
                <p>
                    This chapter reads like a <b>tutorial</b>, and for example source code you should check the <a class="doclink" href="../samples.html#swf-BasicSimulation">BasicSimulation</a> code sample.
                </p>
                <strong><span class="section">Setting up a Space</span></strong>
                <p>
                    A <b>Space</b> is responsive for simulating physics in <b>Nape</b>. We add physics objects such
                    as <b>Bodies</b> and <b>Constraints</b> that will be simulated, and add <b>Listeners</b> to make
                    use of <b>Nape</b> callbacks.
                </p>
                <p>
                    A <b>Space</b> object is instantiated with an optional <b>gravity</b> vector which will be applied
                    to all rigid bodies.
                </p>
                <pre class="prettyprint standard largecodestyle boxedcode">
var gravity:Vec2 = new Vec2(0, 600); // units are pixels/second/second
var space:Space = new Space(gravity);</pre>
                <strong><span class="section">Adding some Bodies</span></strong>
                <p>
                    Creating rigid bodies involves constructing a <b>Body</b> object, and giving it some <b>Shapes</b>.
                </p>
                <p>
                    The <b>Body</b> defines physical <b>positions</b>/<b>rotations</b>/<b>velocities</b>, and <b>Shapes</b> give it a physical
                    form; each <b>Shape</b> has a <b>Material</b> that defines physical properties like <b>friction</b> and <b>density</b>.
                </p>
                <p>
                    When creating a <b>Body</b> we define what type of body it is with the <b>BodyType</b> enumeration.
                </p>
                <pre class="prettyprint standard largecodestyle boxedcode">
var staticBody   :Body = new Body(BodyType.STATIC);
var kinematicBody:Body = new Body(BodyType.KINEMATIC);
var dynamicBody  :Body = new Body(BodyType.DYNAMIC);
var anotherDynamicBody:Body = new Body(); // Default value for BodyType argument is DYNAMIC.</pre>
                <p>
                    <ul>
                        <li>A <b>static</b> body - once assigned to a <b>Space</b> - is fixed; it cannot be moved or rotated, or have <b>Shapes</b> removed from it; a <b>static</b> body has no velocity. We can, however, perform mutations such as changing the shape materials.</li>
                        <li>A <b>kinematic</b> body is similar to a <b>static</b> body, except that it is permitted to have a velocity which will strictly define how the <b>kinematic</b> body moves. Such bodies will not be effected by gravity or any constraints including contacts. You can think of <b>kinematic</b> bodies as being animated.</li>
                        <li>A <b>dynamic</b> body is under control of the physics simulation, it will fall under gravity, be pulled at by constraints and be effected by collisions and buoyancy forces.</li>
                    </ul>
                </p>
                <strong><span class="section">Creating a static floor</span></strong>
                <p>
                    To create a <b>floor</b>, we can make use of a <b>Polygon</b> shape.
                </p>
                <p>
                    <b>Polygons</b> in <b>Nape</b> are defined by a set of convex coordinates; it doesn't matter whether they are in clockwise, or counter-clockwise order. The constructor for the <b>Polygon</b> shape takes as its first argument, the set of coordinates which is dynamically typed to accept one of: <b>Array&lt;Vec2&gt;</b>, <b>Vec2List</b>, <b>flash.Vector&lt;Vec2&gt;</b> or a <b>GeomPoly</b>.
                </p>
                <img width="200" src="../assets/convexity.png" alt="[Convexity]"/>
                <p>
                    The <b>Polygon</b> class also has a few <b>static</b> methods for generating <b>Arrays</b> of <b>Vec2</b> that can be used to construct <b>Polygons</b>.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
var rectangleVertices:Array<Vec2> = Polygon.rect(top-left-x, top-left-y, width, height);
var boxVertices      :Array<Vec2> = Polygon.box(width, height);
// ^ equivalent to Polygon.rect(-width/2, -height/2, width, height);
var pentagonVertices :Array<Vec2> = Polygon.regular(width, height, 5);</pre>
                <p>
                    <table><tr>
                    <td class="dt"><b>NOTE:</b></td>
                    <td class="tdsp"></td>
                    <td>
                    A <b>Body</b> will always rotate about its centre, regardless of where the <b>centre-of-mass</b> exists.
                    For this reason, it is important that a <b>dynamic</b> type <b>Body</b> has its centre-of-mass at local
                    coordinates <b>(0,0)</b>. The <b>Body</b> object has methods to translate its shapes in the local
                    coordinate system, as well as a method <b>align</b> which will apply the necessary translation to move
                    the centre-of-mass to the origin.
                    <br/><br/>
                    If you are creating a <b>dynamic</b> box object, you would then want to use the <b>Polygon.box</b> method
                    to define the vertices, and set the <b>position</b> of the <b>Body</b> to be where you want the box to
                    be created in the <b>Space</b>.
                    </td>
                    </tr></table>
                </p>
                <p>
                    For a <b>static</b> floor object, that is not rotating it does not matter where the <b>centre-of-mass</b> lies, and we are free to use the <b>Polygon.rect</b> method.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
var floorBody:Body = new Body(BodyType.STATIC);
var floorShape:Polygon = new Polygon(Polygon.rect(0, stage.height, stage.width, 1));</pre>
                <p>
                    To add the <b>Shape</b> to the <b>Body</b> we can use one of two methods:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
// Either
floorShape.body = floorBody;
// Or
floorBody.shapes.add(floorShape); // or use the push or unshift methods </pre>
                <p>
                    The choice is entirely up to you, and whichever you consider to be the appropriate style. You can also
                    remove <b>Shapes</b> in the equivalent ways by using the <b>remove</b> method on the <b>ShapeList</b>, or simply setting the <b>body</b> property of the <b>Shape</b> to <b>null</b>.
                </p>
                <p>
                    To add the <b>Body</b> to the <b>Space</b> we have a similar set of choices for adding/removing:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
// Either
floorBody.space = space;
// Or
space.bodies.add(floorBody);</pre>
                <strong><span class="section">Adding a dynamic circle</span></strong>
                <p>
                    For our circle object, we will use the <b>Circle</b> shape type.
                </p>
                <p>
                    <b>Circles</b> in <b>Nape</b> are defined by a <b>radius</b> and a <b>local position</b> in the <b>Body</b> it is assigned to, these are respectively, the arguments to the <b>Circle</b> constructor.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
var circle:Circle = new Circle(10); // local position argument is optional.
var anotherCircle:Circle = new Circle(10, new Vec2(5, 0));</pre>
                <p>
                    We'll position the circle so that it is in the middle of the <b>stage</b> and give it an initial <b>velocity</b>
                    to throw it down to the floor.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
var circleBody:Body = new Body(); // Implicit BodyType.DYNAMIC
circleBody.position.setxy(stage.width/2, stage.height/2);
// or circleBody.position = new Vec2(stage.width/2, stage.height/2);
// or circleBody.position.x = stage.width/2; etc.
circleBody.velocity.setxy(0, 1000);</pre>
                <p>
                    We'd also like this object to be bouncy, for which we defer to the <b>Material</b> object.
                </p>
                <strong><span class="section">Shape Materials</span></strong>
                <p>
                    <b>Materials</b> in <b>Nape</b> define coefficients of <b>dynamic</b>, <b>static</b> and <b>rolling</b>
                    friction, <b>elasticity</b> and <b>density</b> for the <b>Shapes</b> they are assigned to. The <b>density</b> is used in computing the mass, moment of inertia, and centre of mass of a <b>Body</b> whilst the other values are combined in contact calculations and other frictional computations like fluid drag.
                </p>
                <p>
                    We can change the <b>Material</b> of a <b>Shape</b> at any time, even for <b>static</b> <b>Bodies</b>. <b>Shapes</b> are constructed with their own <b>Material</b> object corresponding to the default <b>Material</b>. For
                    the construction of <b>Materials</b>, there are also some pre-set factories as static methods of the <b>Material</b> class.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
// Set individual values
circleShape.material.elasticity = 1;
circleShape.material.density = 4;

// Assign a totally different Material, can use this style to share Materials.
circleShape.material = Material.rubber();</pre>
                <p>
                    To learn how the values of the <b>Materials</b> will be combined, and what the valid ranges are for the properties you should check the API page for <b>Material</b>.
                </p>
                <strong><span class="section">Running the simulation</span></strong>
                <p>
                    To run a simulation, we use the <b>step</b> function on the <b>Space</b>. We will call this function sequentially
                    each frame to advance the simulation, objects will be moved forward based on velocities with <b>gravity</b> and <b>drag</b> being applied. Collision detection will occur with new <b>contacts</b> created, and all <b>constraints</b> will be solved. When using the <b>callbacks</b> system, this function will also invoke your callback handlers.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
// Step forwards in simulation by given amount of seconds.
space.step(deltaTime);</pre>
                <p>
                    We can also specify the number of physics iterations that should be used. These iterations are used to solve the physics
                    constraints and are split into two categories.
                    <table class="dl">
                        <tr><td class="dt"><b>Velocity Iterations</b></td><td class="tdsp"></td><td>In this stage, we are solving all the
                            constraints and contacts to resolve errors in <b>velocities</b> of objects. This is the most important stage
                            in solving the physics system. The default value is <b>10</b></td></tr>
                        <tr><td class="dt"><b>Position Iterations</b></td><td class="tdsp"></td><td>In this stage, we are solving all the
                            constraints and contacts to resolve errors in <b>positions</b> of objects that remain after having solved for
                            velocity errors, and integrated the positions of objects. This stage is necessary to resolve <b>penetrations</b>
                            between objects, and to resolve positional errors of <b>stiff</b> constraints. Position iterations are
                            lighter-weight than velocity iterations and the default value is <b>10</b></td></tr>
                    </table>
                </p>
                <strong><span class="section">Setting up Debug Draw</span></strong>
                <p>
                    <b>Nape</b> provides two methods of debug drawing:
                    <table class="dl">
                        <tr><td class="dt"><b>ShapeDebug</b></td><td class="tdsp"></td><td>Debug drawing using a <b>Sprite</b> with the flash drawing API. This is the most portable debug drawer, working in <b>Haxe</b> through <b>NME</b> for all <b>NME</b> targets.</td></tr>
                        <tr><td class="dt"><b>BitmapDebug</b></td><td class="tdsp"></td><td>Debug drawing using a <b>Bitmap</b> and <b>Alchemy</b> opcodes for extremely fast line drawing. This is available only for <b>flash10+</b> targets and when targeting flash should generally be preferred due to the much higher performance.</td></tr>
                    </table>
                    These objects have equivalent APIs.
                </p>
                <p>
                    The constructors for both debug drawers take as arguments, the <b>width/height</b> of the viewport, and a background colour.
                </p>
                <p>
                    This viewport is used to cull drawing of objects that are not visible (when enabled), and for the <b>BitmapDebug</b>
                    object, defines the size of the bitmap. The background colour is used to <b>tint</b> colours to emulate alpha
                    drawing (Avoiding more expensive alpha-based rendering); for <b>BitmapDebug</b> this defines the base colour
                    for the bitmap.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
var debug:Debug = new BitmapDebug(stage.stageWidth, stage.stageHeight, stage.color);</pre>
                <p>
                    To display the debug view on the screen, you will add <b>debug.display</b> to the <b>DisplayList</b>.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
var display:DisplayObject = debug.display;
addChild(display);</pre>
                <p>
                    The <b>Debug</b> objects have many methods for drawing things like <b>lines</b> and <b>curves</b>, as well as a <b>transform</b> <b>Mat23</b> property that can be used to transform the input geometry (With which we can 'move' our viewport around the world). For this chapter we need only to draw the <b>Space</b>.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
// Clear the debug display.
debug.clear();
// Draw our Space.
debug.draw(space);
// Flush draw calls, until this is called nothing will actually be displayed.
debug.flush();</pre>
            </div>

            <hr class="hrchapter"/>
            <div class="chapter"><strong><span class="title">Interactions</span></strong>
                <div class="contents" id="skip-Interactions"></div>
                <p>
                    <table class="dl">
                        <tr><td class="dt"><b>Collision</b></td><td class="tdsp"></td><td>Default interaction type; when two
                            <b>Shapes</b> intersect (and are able to collide), they will collide with <b>friction</b> and
                            <b>elasticity</b> as defined by the shape <b>Materials</b>.</td></tr>
                        <tr><td class="dt"><b>Sensor</b></td><td class="tdsp"></td><td>With this interaction type, two intersecting <b>Shapes</b> will simply pass through eachother. <b>Arbiter</b> objects will still be created to catalogue the overlap, and you can still receive <b>callbacks</b>.</td></tr>
                        <tr><td class="dt"><b>Fluid</b></td><td class="tdsp"></td><td>This interaction type corresponds to <b>Nape</b>'s implementatino of <b>buoyancy</b>. When two <b>Shapes</b> intersect, the <b>Bodies</b> will receive <b>buoyancy</b> and <b>drag</b> forces as determined by the <b>fluidEnabled</b> <b>Shapes</b>' <b>FluidProperties</b>, and the profiles of the <b>Shapes</b> (A stick will experiance differing drag depending on the direction it moves through the fluid).</td></tr>
                    </table>
                </p>
                <strong><span class="section">Controlling Interactions</span></strong>
                <p>
                    The type of interaction that occurs depends on the shape's <b>InteractionFilters</b>, and the
                    <b>sensorEnabled</b> and <b>fluidEnabled</b> <b>Shape</b> flags.
                </p>
                <p>
                    At a basic level, two <b>static</b> bodies can never interact in any way, and with the exception of
                    <b>sensor</b> interactions, at least one of the bodies must be <b>dynamic</b> for an interaction to occur.
                    This means that the only interaction which can occur between two <b>kinematic</b> bodies, is that of a
                    <b>sensor</b> interaction.
                </p>
                <p>
                    <b>Sensor</b> interactions have the highest precedence, followed by <b>fluid</b> interactions, and finally
                    <b>collision</b> interactions. For any interaction to occur, the <b>InteractionFilters</b> of the shapes
                    must <i>agree</i> to interact. For <b>sensor</b> and <b>fluid</b> interactions, we must additionally have at
                    least one of the <b>Shapes</b> <i>enabled</i> for that interaction type.
                </p>
                <p>
                    The specific procedure used by <b>Nape</b> to decide what sort of interaction occurs is defined like:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
if ((shapeA.sensorEnabled || shapeB.sensorEnabled) &amp;&amp; shapeA.filter.shouldSense(shapeB.filter)) {
    SENSOR INTERACTION!!
}
else if (bodyA.isDynamic() || bodyB.isDynamic()) {
    if ((shapeA.fluidEnabled || shapeB.fluidEnabled) &amp;&amp; shapeA.filter.shouldFlow(shapeB.filter)) {
        FLUID INTERACTION!!
    }
    else if (shapeA.filter.shouldCollide(shapeB.filter)) {
        COLLISION INTERACTION!!
    }
}</pre>
                <strong><span class="section">InteractionFilters</span></strong>
                <p>
                    <b>InteractionFilters</b> work much like you may be familiar with in <b>Box2D</b> and other physics engines.
                    The filters define a <b>group</b> and <b>mask</b> integer, and two filters <i>agree</i> to
                    interact only if:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
(filterA.group &amp; filterB.mask != 0) &amp;&amp; (filterB.group &amp; filterA.mask != 0)</pre>
                <p>
                    <b>Nape</b> takes this concept a step further, by having seperate <b>group</b> and <b>masks</b> for each
                    interaction type. This permits finer grained control on what sort of interaction occurs; it is for
                    example, possible to have a <b>fluidEnabled</b> <b>Shape</b> which due to interaction filters,
                    collides instead.
                </p>
                <p>
                    If you are unfamiliar with thinking of integers are binary values, it is still easy to contruct suitable
                    <b>group</b>/<b>mask</b> values in a pragmatic way. Say we have 3 types of objects: <b>balls</b>,
                    <b>boxes</b> and... <b>donuts</b>. Furthermore let's say that the <b>balls</b> should not collide with
                    <b>boxes</b> or <b>donuts</b>, and <b>donuts</b> should not collide with other <b>donuts</b>.
                </p>
                <p>
                    <table class="table">
                        <tr><td class="border-right border-bottom"></td><td class="border-bottom">Balls</td><td class="border-bottom">Boxes</td><td class="border-bottom">Donuts</td></tr>
                        <tr><td class="border-right">Balls</td><td><b>Yes</b></td><td>No</td><td>No</td></tr>
                        <tr><td class="border-right">Boxes</td><td>No</td><td><b>Yes</b></td><td><b>Yes</b></td></tr>
                        <tr><td class="border-right">Donuts</td><td>No</td><td><b>Yes</b></td><td>No</td></tr>
                    </table>
                </p>
                <p>
                    It is clear this table is symmetric. Now, if we assign <b>groups</b> like:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
ballFilter .collisionGroup = 1; // in binary this is 0000...00001
boxFilter  .collisionGroup = 2; // in binary this is 0000...00010
donutFilter.collisionGroup = 4; // in binary this is 0000...00100</pre>
                <p>
                    Then we can assign <b>masks</b> to match our table - in the most permissive way - like:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
ballFilter .collisionMask = ~(2|4); // in binary this is 1111...11001
boxFilter  .collisionMask = ~1;     // in binary this is 1111...11111
donutFilter.collisionMask = ~(1|4); // in binary this is 1111...11010</pre>
                <p>
                    The reason this works, is that we can interpret the expression
                    <span class="codestyle">(group &amp; mask) != 0</span> as meaning "Group and Mask have at least one bit both
                    equal to 1". In our case, we did not want the <b>donuts</b> to collide amongst themselves, and we seen in
                    the binary representation of the <b>group</b>/<b>mask</b> that the only place the donut group has bit
                    equal to 1 is in the 3rd position, and in the mask, this bit is 0.
                </p>
                <p>
                    The default values for all <b>group</b>/<b>mask</b> properties is <b>1</b> and <b>~0</b> which have
                    binary representations <b>0000...00001</b> and <b>1111...11111</b>.
                </p>
                <strong><span class="section">InteractionGroups</span></strong>
                <p>
                    <b>InteractionGroups</b> provide an additional way of controlling interactions between objects.
                    <b>InteractionGroups</b> can be formed into <b>trees</b> and assigned to <b>Shapes</b>, <b>Bodies</b> and
                    <b>Compounds</b> (Compounds will be discussed later).
                </p>
                <p>
                    Before two <b>Shapes</b> interact, we search for the <b>most-recent common ancestor</b> in the
                    <b>InteractionGroup</b> tree; if that group exists, and is set to <b>ignore</b> interactions, then the
                    two <b>Shapes</b> will not interact.
                </p>
                <img src="../assets/InteractionGroup.png" alt="[InteractionGroup ex.]"/>
                <p>
                    In this example, we have group <b>G1</b> assigned to body <b>B1</b>, group <b>G2</b> assigned to shape
                    <b>S2</b> and compound <b>C1</b>, and has <b>G1</b> as its <b>parent</b>. Group <b>G3</b> is assigned to
                    compound <b>C2</b>. We can compress the example case into the right-hand side graph by looking up the
                    tree to find the closest <b>InteractionGroup</b>.
                </p>
                <p>
                    In this example, should we look at shapes <b>S2</b> and <b>S3</b>, and if <b>G2</b> is set to
                    <b>accept</b> interactions, then <b>S2</b> and <b>S3</b> are permitted to interact. If <b>G1</b> is set
                    to <b>ignore</b> interactions, then <b>S1</b> and <b>S2</b> will <i>not</i> be permitted to interact.
                </p>
                <p>
                    <b>InteractionFilters</b> are more powerful than <b>InteractionGroups</b> in controlling interaction,
                    however <b>InteractionGroups</b> can be very useful. Imagine that we have a robotic mechanism, and we
                    do not want the robot to collide with itself, the easiest way to implement this is to create a
                    <b>Compound</b> containing the robot, and then assigning it to a unique <b>InteractionGroup</b> set
                    to <b>ignore</b> interactions. If we were to use <b>InteractionFilters</b> for this, then we would be
                    forced to <b>use up</b> a bit in the <b>group</b>/<b>mask</b> values, and we would be limited to only
                    a small number of robots.
                </p>
                <strong><span class="section">Constraints</span></strong>
                <p>
                    Though we have not introduced <b>Constraints</b> yet, we must mention one further feature. All
                    <b>Constraints</b> have an <b>ignore</b> property, which if set to <b>true</b> will not permit any of
                    the <b>Bodies</b> related to the <b>Constraint</b> to interact.
                </p>
            </div>

            <hr class="hrchapter"/>
            <div class="chapter"><strong><span class="title">Constraints</span></strong>
                <div class="contents" id="skip-Constraints"></div>
                <p>
                    <b>Constraints</b> in <b>Nape</b> bind bodies together. Typical examples uses would be for things such
                    as rag dolls, cars, and mechanical contraptions.
                </p>
                <p>
                    Most of the <b>Constraint</b> types are <b>positional</b> constraints, such as the <b>PivotJoint</b>
                    which, given two local positions on the <b>Bodies</b>, locks those points together allowing the bodies
                    to mutually rotate about that point. Many constraints are given upper and lower limits such as the
                    <b>DistanceJoint</b> which locks the points on two <b>Bodies</b> to be within a given range of values.
                </p>
                <p>
                    All <b>positional</b> constraints can be set as <b>stiff</b> or <b>elastic</b>. When using <b>elastic</b> constraints,
                    we can set <b>frequency</b> and <b>damping</b> values to control the elastic behaviour, and can set <b>maxForce</b>
                    and <b>maxError</b> to determine how much force is used, and how much error we resolve per second.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
constraint.stiff = false;
constraint.frequency = 30; //Hz
constraint.damping = 10; //Large over-dampening

constraint.maxForce = 1000; // Constraint will use no more than 1000 Newtons to resolve constraint.
constraint.maxError = 10; // Constraint will resolve no more than 10 units of positional error per second.
// The exact behaviour of maxError is dependent on constraint formulation.</pre>
                <p>
                    By setting the appropriate properties, we can also permit a <b>Constraint</b> to be broken if its error becomes too
                    large, or for <b>elastic</b> constraints, if the force required to solve the constraint becomes too large. With
                    the <b>callbacks</b> system, we can receive a callback when a constraint is broken.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
constraint.breakUnderError = true;
constraint.maxError = 10; // If constraint exceeds 10 units of error, constraint will break.
constraint.removeOnBreak = false; // Instead of removing constraint, it will simply be de-activated when broken.</pre>
                <p>
                    Compared to other physics engines, in <b>Nape</b> there is no concept of <b>ownership</b> when it comes
                    to <b>Constraints</b>. If you remove a <b>Body</b>, then any <b>Constraints</b> using the <b>Body</b>
                    that are in the <b>Space</b> will <i>not</i> be removed automatically. The main reason is that you are
                    free to modify what <b>Bodies</b> a <b>Constraint</b> works upon at any time.
                </p>
                <p>
                    To emulate behaviour of other engines, you could use the pattern:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
while (!body.constraints.empty()) {
        body.constraints.at(0).space = null;
}
body.space = null;</pre>
                <p>
                    However, it is very likely that you could achieve better code by making use of <b>Nape</b> <b>Compounds</b>.
                </p>
                <p>
                    As you will be able to see, <b>Constraints</b> have a similar API to <b>Bodies</b> when it comes to adding/removing
                    them from <b>Spaces</b>. The <b>Body</b> <b>constraints</b> list tracks those <b>Constraints</b> which make use of the
                    <b>Body</b>, and which are assigned to a <b>Space</b>, which is why the above pattern works.
                </p>
                <strong><span class="section">PivotJoint</span></strong>
                <p>
                    A <b>PivotJoint</b> locks two points, defined locally to the assigned <b>Bodies</b>, to be the same
                    in <b>world</b> space. The <b>Bodies</b> will then rotate about this point.
                </p>
                <img src="../assets/PivotJoint.png" alt="[PivotJoint diagram]"/>
                <p>
                    You could represent this like:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
body2.localPointToWorld(anchor2) == body1.localPointToWorld(anchor1)</pre>
                <p>
                    Construction of a <b>PivotJoint</b> requires two <b>Bodies</b> together with two <b>Vec2s</b> defining the local anchor points.
                    As is common with all <b>Nape</b> constraints, you are permitted to assign <b>null</b> <b>Bodies</b> whenever the constraint
                    is <b>inactive</b> or not part of a <b>Space</b>.
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
var pivotJoint:Constraint = new PivotJoint(body1, body2, anchor1, anchor2);</pre>
                <p>
                    If instead, you already have the <b>Bodies</b> positioned correctly, and know the <b>world</b> position of the anchors, then you could use the following pattern to construct the <b>PivotJoint</b>
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
var anchor1:Vec2 = body1.worldPointToLocal(anchor);
var anchor2:Vec2 = body2.worldPointToLocal(anchor);
var pivotJoint:Constraint = new PivotJoint(body1, body2, anchor1, anchor2);</pre>

                <strong><span class="section">WeldJoint</span></strong>
                <p>
                    A <b>WeldJoint</b> is like a <b>PivotJoint</b>, except that the relative rotations of the <b>Bodies</b>
                    is also locked to a fixed value. This system is solved together for extra stability compared to using
                    seperate <b>PivotJoint</b> and <b>AngleJoint</b>.
                </p>
                <img src="../assets/WeldJoint.png" alt="[WeldJoint diagram]"/>
                <p>
                    You could represent this like:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
body2.localPointToWorld(anchor2) == body1.localPointToWorld(anchor1)
body2.rotation == body1.rotation + phase</pre>

                <strong><span class="section">DistanceJoint</span></strong>
                <p>
                    A <b>DistanceJoint</b> constrains the distance between two locally defined points on the <b>Bodies</b>
                    to be restricted to a given range.
                </p>
                <p>
                    Please note, that defining a <b>DistanceJoint</b> to have upper and lower limits of <b>0</b> would
                    better be served by using a <b>PivotJoint</b>
                </p>
                <img src="../assets/DistanceJoint.png" alt="[DistanceJoint diagram]"/>
                <p>
                    You could represent this like:
                </p>
                <pre class="prettyprint largecodestyle standard boxedcode">
jointMin &lt;= distance(body2.localPointToWorld(anchor2), body1.localPointToWorld(anchor1)) &lt;= jointMax<lt;/pre>
            </div>
        </div>
        <footer>
            &copy; Luca Deltodesco 2012
        </footer>
    </div>

    <script src="../assets/js/jquery.min.js"></script>
    <script src="../assets/js/default.js"></script>
    <script src="../assets/js/submenu.js"></script>
    <script src="../assets/js/contents.js"></script>
    <script src="../assets/prettify/prettify.js"></script>
    <script src="../assets/js/doclinks.js"></script>
    <script type="text/javascript">
        $(document).ready(function () {
            prettyPrint();
            applyDocLinks();
        });
    </script>
    </body>
</html>

